1.	The O() bound of loadKeys() is O(KL). This is because, using the insert() method we are inserting K keys, where each key is of length L characters into the trie T1. We can see that the insert() method finds the longest prefix of the key and then adds TrieNode(s) to insert the key. Thus, it has to go through a maximum of L node. Therefore, inserting K keys, each of length L will have to go through KL nodes. Thus, the O() bound of loadKeys() is O(KL).
2.	The O() bound of the contains() is O(L). This is because, contains() method has to go through a maximum of L nodes(as the key is of length at most of L characters) is contained in the trie T1. Thus, the O() bound of contains() is O(L).
3.	The O() bound of loadKeys() on T2 is O(KLC). Again, using the insert() method we have to insert K keys where each key is of length L characters into the trie T2. The insert() method finds the longest prefix of the key and then adds TrieNode(s) to insert the key and therefore, has to go through a maximum of L nodes. In order to correctly access the L nodes, it first has to go through the ones already present in the parent node of the LinkedList. As we know, the LinkedList can have a maximum of C nodes. So, total traversal to the L nodes is LC nodes. Now, we have to travel K(LC) nodes after inserting K keys with the insert() method. Thus, giving O() bound of loadKeys() to be O(KLC).
4.	The contains() method has to go through a maximum of L nodes (as the input key is of length at most L characters) to check to see if the key is contained in the trie T2. Although, in order to correctly access the L nodes, it first has to traverse through the ones already present in the parent node of the LinkedList. So, the total traversal is LC nodes (as the LinkedList can have a maximum of C nodes). Thus, O() bound of contains() is O(LC).
5.	The O() bound of loadKeys() will be O(LC). This is because, we are to consider a BST data structure that inserts K keys. For the worst case, the BST is not well-balanced, then all the other nodes will be smaller or bigger than the particular node to be inserted. So, at every step of the algorithm we have to compare lexicographically at least L times. As we have a total of C nodes in the BST, this brings us to O() bound of loadKeys() to be O(LC).
6.	The Omega() bound of loadKeys() will be O(log_2(LC)). This is because, we are to consider a BST data structure that inserts K keys. For the best case, we take the BST to be well-balanced, thus giving us a complete Binary Tree. There are C nodes in the BST and the algorithm would have to go through log_2() node of the BST, where is to be compared lexicographically L times at every step. Therefore, that gives us Omega() bound of the loadKeys() to be O(log_2(LC)).
7.	O() bound of contains() will be O(LC). This is because, for the worst case, we have BST that is not well-balanced i.e. all the other nodes will be smaller or bigger than the particular node to be inserted. So, at every step of the algorithm we have to compare lexicographically at least L times. We have C nodes in total in the BST. So that would give O() bound of contains to be O(LC).
8.	The Omega() bound of contains() will be O(log_2(LC)). This is because, in order to get the best case, we have to consider a BST which is balanced i.e. it is a complete Binary Tree. There are C nodes in the BST and the algorithm would have to go through log_2() node of the BST, where is to be compared lexicographically L times at every step. Therefore, this gives Omega() bound of contains() to be O(log_2(LC)).